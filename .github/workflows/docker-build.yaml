name: Build Docker Image

on:
  workflow_call:
    inputs:
      runs-on:
        required: false
        type: string
        default: "ubuntu-latest"
      timeout-minutes:
        required: false
        type: number
        default: 360
      docker-platforms:
        required: false
        type: string
        default: "linux/amd64,linux/arm64"
      docker-context:
        required: false
        type: string
        default: .
      dockerfile:
        required: false
        type: string
        default: "./Dockerfile"
      image_subpath:
        required: false
        type: string
      dockerhub_imagename:
        required: false
        type: string
        default: ""
      build-args:
        required: false
        type: string
        default: ""
      additional-tag:
        required: false
        type: string
        default: ""
      alternate-latest-mode:
        required: false
        type: boolean
        default: false
      push:
        required: false
        type: boolean
        default: true
        description: "Whether or not to attempt to push the image to the registry"
      artifacts-name:
        required: false
        type: string
        description: "Whether artifacts should be downloaded before building the image"
      artifacts-path:
        required: false
        type: string
        description: "Path to place artifacts, if downloading"
      enable-cache:
        required: false
        type: string
        default: "false"
        description: Should the builds use docker cache
      enable-qemu-cache:
        required: false
        type: string
        default: "true"
        description: "Cache binfmt image to GitHub Actions cache backend"
    secrets:
      DOCKERHUB_USERNAME:
        required: false
      DOCKERHUB_PAT:
        required: false

jobs:
  package:
    runs-on: ${{ inputs.runs-on }}
    timeout-minutes: ${{ inputs.timeout-minutes }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          cache-image: ${{ inputs.enable-qemu-cache }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3.11.1

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Login to DockerHub
        env:
          dockerhub_username: ${{ secrets.DOCKERHUB_USERNAME }}
          dockerhub_pat: ${{ secrets.DOCKERHUB_PAT }}
        if: ${{ env.dockerhub_username != '' && env.dockerhub_pat != '' }}
        uses: docker/login-action@v3
        with:
          username: ${{ env.dockerhub_username }}
          password: ${{ env.dockerhub_pat }}

      - name: Set image name
        id: image
        run: |
          export subpath="${{ inputs.image_subpath }}"
          if [ "$subpath" == '' ]; then
            echo "imagename=ghcr.io/${{ github.repository }}" >> "$GITHUB_OUTPUT"
          else
            echo "imagename=ghcr.io/${{ github.repository }}/${subpath}" >> "$GITHUB_OUTPUT"
          fi

      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ steps.image.outputs.imagename }}
            ${{ inputs.dockerhub_imagename }}
          flavor: |
            latest=auto
            prefix=
            suffix=
          tags: |
            type=raw,value=main,enable={{is_default_branch}}
            type=raw,value=latest,enable=${{ inputs.alternate-latest-mode && endsWith(github.ref, github.event.repository.default_branch) }}
            type=raw,value=${{ inputs.additional-tag }},enable=${{ inputs.additional-tag != '' }}
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha,format=long

      - name: Download artifacts if set
        if: ${{ inputs.artifacts-name != '' && inputs.artifacts-path != '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifacts-name }}
          path: ${{ inputs.artifacts-path }}

      - name: Cache
        if: ${{ inputs.enable-cache == 'true' }}
        uses: actions/cache@v4
        with:
          path: docker-cache
          key: ${{ runner.os }}-docker-cache

      - name: Build Docker Container
        uses: docker/build-push-action@v6
        with:
          context: ${{ inputs.docker-context }}
          file: ${{ inputs.dockerfile }}
          platforms: ${{ inputs.docker-platforms }}
          push: ${{ inputs.push }}
          tags: ${{ steps.meta.outputs.tags }}
          build-args: ${{ inputs.build-args }}
          cache-from: type=local,src=docker-cache
          cache-to: type=local,dest=docker-cache-new

      - name: Report image sizes
        run: |
          echo "## ðŸ“¦ Docker Image Sizes" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get the first tag from meta output (usually has the SHA)
          FIRST_TAG=$(echo "${{ steps.meta.outputs.tags }}" | head -n 1)
          echo "**Image:** \`$FIRST_TAG\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "| Architecture | Compressed Size | Uncompressed Size |" >> $GITHUB_STEP_SUMMARY
          echo "|--------------|-----------------|-------------------|" >> $GITHUB_STEP_SUMMARY

          # Parse platforms
          IFS=',' read -ra PLATFORMS <<< "${{ inputs.docker-platforms }}"

          for platform in "${PLATFORMS[@]}"; do
            platform=$(echo "$platform" | xargs)
            echo "Getting size for $platform..."
            
            # Use imagetools to inspect the specific platform
            if MANIFEST_INFO=$(docker buildx imagetools inspect "$FIRST_TAG" --format 'json' 2>/dev/null); then
              # Parse the JSON to find our platform
              os=$(echo "$platform" | cut -d'/' -f1)
              arch=$(echo "$platform" | cut -d'/' -f2)
              
              # Extract sizes for this specific platform
              PLATFORM_INFO=$(echo "$MANIFEST_INFO" | jq -r --arg os "$os" --arg arch "$arch" '
                .manifests[]? | 
                select(.platform.os == $os and .platform.architecture == $arch) |
                {
                  size: .size,
                  digest: .digest
                }
              ' 2>/dev/null)
              
              if [ -n "$PLATFORM_INFO" ] && [ "$PLATFORM_INFO" != "null" ]; then
                COMPRESSED_SIZE=$(echo "$PLATFORM_INFO" | jq -r '.size // 0')
                DIGEST=$(echo "$PLATFORM_INFO" | jq -r '.digest // ""')
                
                if [ "$COMPRESSED_SIZE" != "0" ] && [ "$COMPRESSED_SIZE" != "null" ]; then
                  # Convert compressed size to human readable
                  comp_mb=$((COMPRESSED_SIZE / 1024 / 1024))
                  if [ $comp_mb -ge 1024 ]; then
                    comp_gb=$((comp_mb / 1024))
                    comp_display="${comp_gb}.$(( (comp_mb % 1024) * 10 / 1024 ))GB"
                  else
                    comp_display="${comp_mb}MB"
                  fi
                  
                  # Get uncompressed size by inspecting the specific platform image
                  if UNCOMPRESSED_SIZE=$(docker buildx imagetools inspect "$FIRST_TAG@$DIGEST" --format '{{.Config.Size}}' 2>/dev/null); then
                    if [ -n "$UNCOMPRESSED_SIZE" ] && [ "$UNCOMPRESSED_SIZE" != "0" ]; then
                      uncomp_mb=$((UNCOMPRESSED_SIZE / 1024 / 1024))
                      if [ $uncomp_mb -ge 1024 ]; then
                        uncomp_gb=$((uncomp_mb / 1024))
                        uncomp_display="${uncomp_gb}.$(( (uncomp_mb % 1024) * 10 / 1024 ))GB"
                      else
                        uncomp_display="${uncomp_mb}MB"
                      fi
                    else
                      uncomp_display="N/A"
                    fi
                  else
                    uncomp_display="N/A"
                  fi
                  
                  echo "| \`$platform\` | \`$comp_display\` | \`$uncomp_display\` |" >> $GITHUB_STEP_SUMMARY
                  echo "âœ… $platform: $comp_display (compressed), $uncomp_display (uncompressed)"
                else
                  echo "| \`$platform\` | âš ï¸  Size unavailable | âš ï¸  Size unavailable |" >> $GITHUB_STEP_SUMMARY
                  echo "âš ï¸  $platform: Could not determine size"
                fi
              else
                echo "| \`$platform\` | âŒ Platform not found | âŒ Platform not found |" >> $GITHUB_STEP_SUMMARY
                echo "âŒ $platform: Platform not found in manifest"
              fi
            else
              echo "| \`$platform\` | âŒ Failed to inspect | âŒ Failed to inspect |" >> $GITHUB_STEP_SUMMARY
              echo "âŒ $platform: Failed to inspect image"
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ’¡ **Notes:**" >> $GITHUB_STEP_SUMMARY
          echo "- **Compressed Size:** Size when stored in registry (with layer compression)" >> $GITHUB_STEP_SUMMARY
          echo "- **Uncompressed Size:** Actual disk usage when image is pulled and extracted" >> $GITHUB_STEP_SUMMARY
          echo "- Focus on uncompressed size for optimizing disk usage efficiency" >> $GITHUB_STEP_SUMMARY

      - # Fixes
        # https://github.com/docker/build-push-action/issues/252
        # https://github.com/moby/buildkit/issues/1896
        name: Move cache
        if: ${{ inputs.enable-cache == 'true' }}
        run: |
          rm -rf docker-cache
          mv docker-cache-new docker-cache
